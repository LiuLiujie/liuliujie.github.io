const e=JSON.parse(`{"key":"v-3c1d1bfb","path":"/blogs/java/java-concurrency.html","title":"Java Concurrency","lang":"en-US","frontmatter":{"category":["Computer Science","Programming Language"],"tag":["Java"],"description":"Java Concurrency 获取线程的执行结果 创建线程有 3 种方式，一种是直接继承 Thread，一种是实现 Runnable 接口，另外一种是实现 Callable 接口。前 2 种方式都有一个缺陷：在执行完任务之后无法获取执行结果。 如果需要获取执行结果，就必须通过共享变量或者线程通信的方式来达到目的，这样使用起来就比较麻烦。 Java 1.5 提供了 Callable、Future、FutureTask，它们可以在任务执行完后得到执行结果。 Callable接口 Callable接口定义了一个 call() 方法，返回的类型是一个 V 类型的范型。在之前的例子中，我们使用String来作为范型的具体类型。","head":[["meta",{"property":"og:url","content":"https://blog.yujieliu.com/blogs/java/java-concurrency.html"}],["meta",{"property":"og:site_name","content":"Yujie's blog"}],["meta",{"property":"og:title","content":"Java Concurrency"}],["meta",{"property":"og:description","content":"Java Concurrency 获取线程的执行结果 创建线程有 3 种方式，一种是直接继承 Thread，一种是实现 Runnable 接口，另外一种是实现 Callable 接口。前 2 种方式都有一个缺陷：在执行完任务之后无法获取执行结果。 如果需要获取执行结果，就必须通过共享变量或者线程通信的方式来达到目的，这样使用起来就比较麻烦。 Java 1.5 提供了 Callable、Future、FutureTask，它们可以在任务执行完后得到执行结果。 Callable接口 Callable接口定义了一个 call() 方法，返回的类型是一个 V 类型的范型。在之前的例子中，我们使用String来作为范型的具体类型。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-03-15T17:45:22.000Z"}],["meta",{"property":"article:author","content":"Yujie Liu"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:modified_time","content":"2024-03-15T17:45:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java Concurrency\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-15T17:45:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yujie Liu\\",\\"url\\":\\"https://blog.yujieliu.com/intro.html\\"}]}"]]},"headers":[{"level":2,"title":"获取线程的执行结果","slug":"获取线程的执行结果","link":"#获取线程的执行结果","children":[{"level":3,"title":"Callable接口","slug":"callable接口","link":"#callable接口","children":[]}]},{"level":2,"title":"线程的声明周期与状态","slug":"线程的声明周期与状态","link":"#线程的声明周期与状态","children":[]},{"level":2,"title":"多线程带来的问题","slug":"多线程带来的问题","link":"#多线程带来的问题","children":[{"level":3,"title":"线程死锁","slug":"线程死锁","link":"#线程死锁","children":[]},{"level":3,"title":"线程安全：确保多线程数据一致性","slug":"线程安全-确保多线程数据一致性","link":"#线程安全-确保多线程数据一致性","children":[]}]}],"git":{"createdTime":1700904375000,"updatedTime":1710524722000,"contributors":[{"name":"Jeff Liu","email":"47711081+LiuLiujie@users.noreply.github.com","commits":1},{"name":"Yujie","email":"yujie.liu.public@gmail.com","commits":1}]},"readingTime":{"minutes":3.19,"words":958},"filePathRelative":"blogs/java/java-concurrency.md","localizedDate":"November 25, 2023","excerpt":"<h1> Java Concurrency</h1>\\n<h2> 获取线程的执行结果</h2>\\n<p>创建线程有 3 种方式，一种是直接继承 Thread，一种是实现 Runnable 接口，另外一种是实现 Callable 接口。前 2 种方式都有一个缺陷：在执行完任务之后无法获取执行结果。</p>\\n<p>如果需要获取执行结果，就必须通过共享变量或者线程通信的方式来达到目的，这样使用起来就比较麻烦。</p>\\n<p>Java 1.5 提供了 Callable、Future、FutureTask，它们可以在任务执行完后得到执行结果。</p>\\n<h3> Callable接口</h3>\\n<p>Callable接口定义了一个 <code>call()</code> 方法，返回的类型是一个 V 类型的范型。在之前的例子中，我们使用String来作为范型的具体类型。</p>","autoDesc":true}`);export{e as data};
