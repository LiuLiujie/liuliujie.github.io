import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as i,c,a as n,b as a,e as r,d as e}from"./app-9e8a13db.js";const p={},l=e('<h1 id="bean的生命周期" tabindex="-1"><a class="header-anchor" href="#bean的生命周期" aria-hidden="true">#</a> Bean的生命周期</h1><p>Bean 的生命周期概括起来就是 <strong>4 个阶段</strong>：</p><ol><li><p>实例化（Instantiation）：第 1 步，实例化一个 bean 对象；</p></li><li><p>属性赋值（Populate）：第 2 步，为 bean 设置相关属性和依赖；</p></li><li><p>初始化（Initialization）：第 3~7 步，步骤较多，其中第 5、6 步为初始化操作，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，该阶段结束，才能被用户使用；</p></li><li><p>销毁（Destruction）：第 8~10步，第8步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 bean 时再执行相应的方法。</p></li></ol><p><img src="https://pics.yujieliu.com/blog/2023/11/7c374cad4812be70e763e4001088c9b6.png" alt="image-20231124202408750"></p>',4),d={href:"https://github.com/LiuLiujie/bean-life-cycle",target:"_blank",rel:"noopener noreferrer"},u=e(`<h3 id="_1-示例化" tabindex="-1"><a class="header-anchor" href="#_1-示例化" aria-hidden="true">#</a> 1.示例化</h3><p>可以通过@Component注解开始进行示例化；</p><p>也可以xml进行示例化，在Application的main上标注<code>@ImportResource(&quot;classpath:xxx.xml&quot;)</code>，然后把文件放在resources里。</p><h3 id="_2-属性赋值" tabindex="-1"><a class="header-anchor" href="#_2-属性赋值" aria-hidden="true">#</a> 2.属性赋值</h3><p>根据xml里的配置对属性进行setter赋值</p><h3 id="_3-aware接口" tabindex="-1"><a class="header-anchor" href="#_3-aware接口" aria-hidden="true">#</a> 3.Aware接口</h3><p>若 Spring 检测到 bean 实现了 Aware 接口，则会为其注入相应的依赖。所以<strong>通过让bean 实现 Aware 接口，则能在 bean 中获得相应的 Spring 容器资源</strong>。</p><p>Spring 中提供的 Aware 接口有，以下按顺序进行执行：</p><h4 id="_3-1-beannameaware" tabindex="-1"><a class="header-anchor" href="#_3-1-beannameaware" aria-hidden="true">#</a> 3.1 BeanNameAware</h4><p>注入当前 bean 对应 beanName；</p><h4 id="_3-2-beanclassloaderaware" tabindex="-1"><a class="header-anchor" href="#_3-2-beanclassloaderaware" aria-hidden="true">#</a> 3.2 BeanClassLoaderAware</h4><p>注入加载当前 bean 的 ClassLoader，让bean知道其父是谁（双亲委派机制）</p><h4 id="_3-3-beanfactoryaware" tabindex="-1"><a class="header-anchor" href="#_3-3-beanfactoryaware" aria-hidden="true">#</a> 3.3 BeanFactoryAware</h4><p>注入当前 BeanFactory 容器的引用，是哪个工厂初始化的bean。</p><h3 id="_4-和-7-beanpostprocesser前后置处理" tabindex="-1"><a class="header-anchor" href="#_4-和-7-beanpostprocesser前后置处理" aria-hidden="true">#</a> 4. 和 7. BeanPostProcesser前后置处理</h3><p>我们可以实现下面的两个方法来做到第4步和第7步。</p><p>注意这两个方法是会被所有的bean都用到的，因此相比前面的Aware接口是仅仅对那个类进行处理，这个方法的实现是针对所有的Bean。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">{</span>

	<span class="token comment">// 初始化前置处理</span>
	<span class="token keyword">default</span> <span class="token class-name">Object</span> <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> bean<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 初始化后置处理</span>
	<span class="token keyword">default</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> bean<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
  
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="postconstruct注解在此时进行" tabindex="-1"><a class="header-anchor" href="#postconstruct注解在此时进行" aria-hidden="true">#</a> <code>@Postconstruct</code>注解在此时进行</h3><h3 id="_5-和-6-initializingbean-和-init-method" tabindex="-1"><a class="header-anchor" href="#_5-和-6-initializingbean-和-init-method" aria-hidden="true">#</a> 5.和 6. InitializingBean 和 init-method</h3><p>InitializingBean 和 init-method 是 Spring 为 <strong>bean 初始化</strong>提供的扩展点，两个基本差不多，区别有：</p><ul><li>前一个通过实现<code>InitializingBean</code>接口的<code>void afterPropertiesSet()</code>方法进行处理</li><li>而后者则需要通过xml文件进行配置来调用</li></ul><h3 id="predestroy注解在此时进行" tabindex="-1"><a class="header-anchor" href="#predestroy注解在此时进行" aria-hidden="true">#</a> <code>@PreDestroy注解</code>在此时进行</h3><h3 id="_8-destructionawarebeanpostprocessor接口" tabindex="-1"><a class="header-anchor" href="#_8-destructionawarebeanpostprocessor接口" aria-hidden="true">#</a> 8. DestructionAwareBeanPostProcessor接口</h3><p>和前面的一样，通过实现下面的方法来对<strong>所有</strong>bean的销毁进行处理</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DestructionAwareBeanPostProcessor</span> <span class="token keyword">extends</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">{</span>
  
	<span class="token keyword">void</span> <span class="token function">postProcessBeforeDestruction</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-和-10-实现disposablebean和destroy-method" tabindex="-1"><a class="header-anchor" href="#_9-和-10-实现disposablebean和destroy-method" aria-hidden="true">#</a> 9. 和 10. 实现DisposableBean和destroy-method</h3><p>DisposableBean和destroy-method都是针对某个bean进行的自定义的销毁方法</p><ul><li>前一个通过实现DisposableBean接口的<code>void destroy()</code>方法进行处理</li><li>而后者则需要通过xml文件进行配置来调用</li></ul>`,29);function h(b,m){const s=o("ExternalLinkIcon");return i(),c("div",null,[l,n("p",null,[a("这里有个"),n("a",d,[a("小项目"),r(s)]),a("来演示生命周期的流程，建议配合观看。")]),u])}const _=t(p,[["render",h],["__file","bean-lifecycle.html.vue"]]);export{_ as default};
