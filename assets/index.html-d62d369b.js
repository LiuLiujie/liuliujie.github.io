import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as h,o,c as n,a as e,b as a,e as r,w as t,d as l}from"./app-9e8a13db.js";const s={},c=l('<h1 id="java-roadmap-学习路线" tabindex="-1"><a class="header-anchor" href="#java-roadmap-学习路线" aria-hidden="true">#</a> Java Roadmap 学习路线</h1><h3 id="java字符串" tabindex="-1"><a class="header-anchor" href="#java字符串" aria-hidden="true">#</a> Java字符串</h3><ul><li><p>常用方法</p></li><li><p>不可变性</p><p>final修饰，每次修改都创建新字符串到常量池，相当于值引用</p></li><li><p>StringBuilder与StringBuffer</p><p>Buffer加了synchronized锁，因此常用Builder，并在并发下配合ThreadLocal</p></li><li><p>字符串常量池</p><p><code>String s = new String(&quot;ABC&quot;);</code>: 先在字符串常量池中创建对象“ABC”，然后再在堆上创建对象“ABC”</p></li></ul>',3),u={id:"java-io",tabindex:"-1"},p=e("a",{class:"header-anchor",href:"#java-io","aria-hidden":"true"},"#",-1),v={id:"java-传统io-bio",tabindex:"-1"},_=e("a",{class:"header-anchor",href:"#java-传统io-bio","aria-hidden":"true"},"#",-1),f={id:"java-nio",tabindex:"-1"},j=e("a",{class:"header-anchor",href:"#java-nio","aria-hidden":"true"},"#",-1),b={id:"java-aio",tabindex:"-1"},x=e("a",{class:"header-anchor",href:"#java-aio","aria-hidden":"true"},"#",-1),m=l('<h2 id="java-集合框架-collections" tabindex="-1"><a class="header-anchor" href="#java-集合框架-collections" aria-hidden="true">#</a> Java 集合框架 (Collections)</h2><h3 id="set-list" tabindex="-1"><a class="header-anchor" href="#set-list" aria-hidden="true">#</a> Set &amp; List</h3><ul><li><p>ArrayList 和 LinkedList</p></li><li><p>ArrayList 详解</p></li><li><p>LinkedList 详解</p></li><li><p>范型</p></li><li><p>Iterator和Iterable</p></li><li><p>For Loop循环</p></li></ul><h3 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h3><ul><li><p>HashMap详解</p></li><li><p>LinkedHashMap详解</p></li></ul><h3 id="collections-arrays-工具类" tabindex="-1"><a class="header-anchor" href="#collections-arrays-工具类" aria-hidden="true">#</a> Collections &amp; Arrays 工具类</h3>',6),J={id:"java-并发编程-concurrency",tabindex:"-1"},L=e("a",{class:"header-anchor",href:"#java-并发编程-concurrency","aria-hidden":"true"},"#",-1),y=l('<h3 id="线程与进程" tabindex="-1"><a class="header-anchor" href="#线程与进程" aria-hidden="true">#</a> 线程与进程</h3><ul><li>操作系统的线程与进程</li><li>Java的线程与进程</li><li>Java线程的6种状态与转移</li><li>线程组与线程优先级</li><li>多线程带来的问题</li><li>协程</li></ul><h3 id="java内存模型" tabindex="-1"><a class="header-anchor" href="#java内存模型" aria-hidden="true">#</a> Java内存模型</h3><ul><li>volatile 关键字</li></ul><h3 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h3><ul><li>syncronized 关键字与锁升级</li><li>偏向锁</li><li>乐观锁 CAS</li><li>抽象队列同步器 AQS</li><li>锁分类和 JUC 包</li><li>重入锁</li></ul><h3 id="并发容器" tabindex="-1"><a class="header-anchor" href="#并发容器" aria-hidden="true">#</a> 并发容器</h3><ul><li>ConcurrentHashMap</li></ul><h3 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h3><h2 id="java-反射与面向切面编程" tabindex="-1"><a class="header-anchor" href="#java-反射与面向切面编程" aria-hidden="true">#</a> Java 反射与面向切面编程</h2>',10);function B(C,I){const i=h("RouterLink");return o(),n("div",null,[c,e("h2",u,[p,a(),r(i,{to:"/blogs/java/JavaIO/"},{default:t(()=>[a("Java IO")]),_:1})]),e("h3",v,[_,a(),r(i,{to:"/blogs/java/JavaIO/java-io.html"},{default:t(()=>[a("Java 传统IO (BIO)")]),_:1})]),e("h3",f,[j,a(),r(i,{to:"/blogs/java/JavaIO/java-nio.html"},{default:t(()=>[a("Java NIO")]),_:1})]),e("h3",b,[x,a(),r(i,{to:"/blogs/java/JavaIO/java-aio.html"},{default:t(()=>[a("Java AIO")]),_:1})]),m,e("h2",J,[L,a(),r(i,{to:"/blogs/java/java-concurrency.html"},{default:t(()=>[a("Java 并发编程 (Concurrency)")]),_:1})]),y])}const O=d(s,[["render",B],["__file","index.html.vue"]]);export{O as default};
