const e=JSON.parse(`{"key":"v-53949d84","path":"/blogs/algorithm/backtracking.html","title":"Backtracking Algorithm 回溯算法","lang":"en-US","frontmatter":{"category":"Computer Science","tag":["Algorithms","Leetcode","Backtracking"],"description":"Backtracking Algorithm 回溯算法 In a netshell 解题思路 In abraction, solving a backtracking problem is acutally iterating a decision tree. Every node of a tree has a valid answer and we traversing the tree to collect all the valid answers. 抽象地说，解决一个回溯问题，实际上就是遍历一棵决策树的过程，树的每个叶子节点存放着一个合法答案。你把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案。","head":[["meta",{"property":"og:url","content":"https://blog.yujieliu.com/blogs/algorithm/backtracking.html"}],["meta",{"property":"og:site_name","content":"Yujie's blog"}],["meta",{"property":"og:title","content":"Backtracking Algorithm 回溯算法"}],["meta",{"property":"og:description","content":"Backtracking Algorithm 回溯算法 In a netshell 解题思路 In abraction, solving a backtracking problem is acutally iterating a decision tree. Every node of a tree has a valid answer and we traversing the tree to collect all the valid answers. 抽象地说，解决一个回溯问题，实际上就是遍历一棵决策树的过程，树的每个叶子节点存放着一个合法答案。你把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-11-25T09:26:15.000Z"}],["meta",{"property":"article:author","content":"Yujie Liu"}],["meta",{"property":"article:tag","content":"Algorithms"}],["meta",{"property":"article:tag","content":"Leetcode"}],["meta",{"property":"article:tag","content":"Backtracking"}],["meta",{"property":"article:modified_time","content":"2023-11-25T09:26:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Backtracking Algorithm 回溯算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-11-25T09:26:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yujie Liu\\",\\"url\\":\\"https://blog.yujieliu.com/intro.html\\"}]}"]]},"headers":[{"level":2,"title":"In a netshell 解题思路","slug":"in-a-netshell-解题思路","link":"#in-a-netshell-解题思路","children":[]},{"level":2,"title":"Two Examples 举个栗子","slug":"two-examples-举个栗子","link":"#two-examples-举个栗子","children":[{"level":3,"title":"T46. Permutations 全排列","slug":"t46-permutations-全排列","link":"#t46-permutations-全排列","children":[]},{"level":3,"title":"T51. N-Queens N 皇后问题","slug":"t51-n-queens-n-皇后问题","link":"#t51-n-queens-n-皇后问题","children":[]}]}],"git":{"createdTime":1700904375000,"updatedTime":1700904375000,"contributors":[{"name":"Yujie","email":"yujie.liu.public@gmail.com","commits":1}]},"readingTime":{"minutes":2.77,"words":832},"filePathRelative":"blogs/algorithm/backtracking.md","localizedDate":"November 25, 2023","excerpt":"<h1> Backtracking Algorithm 回溯算法</h1>\\n<h2> In a netshell 解题思路</h2>\\n<p><strong>In abraction, solving a backtracking problem is acutally iterating a decision tree. Every node of a tree has a valid answer and we traversing the tree to collect all the valid answers.  抽象地说，解决一个回溯问题，实际上就是遍历一棵决策树的过程，树的每个叶子节点存放着一个合法答案。你把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案</strong>。</p>","autoDesc":true}`);export{e as data};
