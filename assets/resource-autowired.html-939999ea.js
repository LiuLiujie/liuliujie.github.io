const e=JSON.parse(`{"key":"v-fba93b22","path":"/blogs/springboot/resource-autowired.html","title":"@Resource和@Autowired与@Qualifier","lang":"en-US","frontmatter":{"category":["Computer Science","Backend Development"],"tag":["Springboot"],"description":"@Resource和@Autowired与@Qualifier @Resource和@Autowired都是做bean的注入时使用 @Resource不是Spring中的注解，但是Spring支持该注解，而@Autowired是Spring的注解 @Autowired是按照类型(byType)来装配Bean的，不会去匹配name，默认情况下他要求依赖对象必须存在，如果需允许null，可以设置它的required属性为false，如果想让@Autowired按照名称（byName）来装配，则需要配合@Qualifier一起使用，Bean的实例名称由@qualifier注解的value参数指定 @Resource则同时有name、type属性，Spring将name属性解析为Bean实例名称，将type属性解析为Bean的梳理类型。Spring先按照Bean实例名称装配，如果不能装配，则按照Bean的类型进行装配，如果都不能匹配，抛出NoSuchBeanDefinitionException异常。","head":[["meta",{"property":"og:url","content":"https://blog.yujieliu.com/blogs/springboot/resource-autowired.html"}],["meta",{"property":"og:site_name","content":"Yujie's blog"}],["meta",{"property":"og:title","content":"@Resource和@Autowired与@Qualifier"}],["meta",{"property":"og:description","content":"@Resource和@Autowired与@Qualifier @Resource和@Autowired都是做bean的注入时使用 @Resource不是Spring中的注解，但是Spring支持该注解，而@Autowired是Spring的注解 @Autowired是按照类型(byType)来装配Bean的，不会去匹配name，默认情况下他要求依赖对象必须存在，如果需允许null，可以设置它的required属性为false，如果想让@Autowired按照名称（byName）来装配，则需要配合@Qualifier一起使用，Bean的实例名称由@qualifier注解的value参数指定 @Resource则同时有name、type属性，Spring将name属性解析为Bean实例名称，将type属性解析为Bean的梳理类型。Spring先按照Bean实例名称装配，如果不能装配，则按照Bean的类型进行装配，如果都不能匹配，抛出NoSuchBeanDefinitionException异常。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-11-27T20:57:56.000Z"}],["meta",{"property":"article:author","content":"Yujie Liu"}],["meta",{"property":"article:tag","content":"Springboot"}],["meta",{"property":"article:modified_time","content":"2023-11-27T20:57:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"@Resource和@Autowired与@Qualifier\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-11-27T20:57:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yujie Liu\\",\\"url\\":\\"https://blog.yujieliu.com/intro.html\\"}]}"]]},"headers":[],"git":{"createdTime":1701118676000,"updatedTime":1701118676000,"contributors":[{"name":"Yujie","email":"yujie.liu.public@gmail.com","commits":1}]},"readingTime":{"minutes":0.71,"words":213},"filePathRelative":"blogs/springboot/resource-autowired.md","localizedDate":"November 27, 2023","excerpt":"<h1> @Resource和@Autowired与@Qualifier</h1>\\n<ul>\\n<li>\\n<p>@Resource和@Autowired都是做bean的注入时使用</p>\\n</li>\\n<li>\\n<p>@Resource不是Spring中的注解，但是Spring支持该注解，而@Autowired是Spring的注解</p>\\n</li>\\n<li>\\n<p><strong>@Autowired</strong>是按照<strong>类型(byType)<strong>来装配Bean的，不会去匹配name，默认情况下他要求依赖对象必须存在，如果需允许null，可以设置它的required属性为false，如果想让@Autowired按照名称（byName）来装配，则需要配合</strong>@Qualifier</strong>一起使用，Bean的实例名称由@qualifier注解的value参数指定</p>\\n</li>\\n<li>\\n<p><strong>@Resource</strong>则<strong>同时有name、type</strong>属性，Spring将name属性解析为Bean实例名称，将type属性解析为Bean的梳理类型。Spring先按照Bean实例名称装配，如果不能装配，则按照Bean的类型进行装配，如果都不能匹配，抛出NoSuchBeanDefinitionException异常。</p>\\n</li>\\n</ul>","autoDesc":true}`);export{e as data};
