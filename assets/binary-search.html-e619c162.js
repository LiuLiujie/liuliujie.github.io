const e=JSON.parse(`{"key":"v-22e1a2fc","path":"/blogs/algorithm/binary-search.html","title":"Binary Search 二分搜索","lang":"en-US","frontmatter":{"category":"Computer Science","tag":["Algorithms","Leetcode","Binary Search"],"description":"Binary Search 二分搜索 二分搜索的关键在于： 搜索 [0, len-1] 这个闭区间，还是 [0, len) 这个开区间. 如果是闭区间，则循环条件使用 while(left &lt;= right)；如果是开区间，则使用while(left &lt; right)。很好理解，考虑列表只有一个因素的情况，闭区间是[1,1]需要等于搜索。 思考返回的问题： 如果元素是不重复的，可以直接if(nums[mid] == target) return mid;判断返回。 如果元素是重复的，需要考虑返回第一个重复元素还是最后一个重复元素的问题。 返回第一个：if (nums[mid] == target) right = mid - 1; 锁定左侧边界，返回值为：return nums[left] == target ? left : -1; 返回最后一个：if (nums[mid] == target) left = mid + 1; 锁定右侧边界，返回值为：nums[right] == target ? right : -1;","head":[["meta",{"property":"og:url","content":"https://blog.yujieliu.com/blogs/algorithm/binary-search.html"}],["meta",{"property":"og:site_name","content":"Yujie's blog"}],["meta",{"property":"og:title","content":"Binary Search 二分搜索"}],["meta",{"property":"og:description","content":"Binary Search 二分搜索 二分搜索的关键在于： 搜索 [0, len-1] 这个闭区间，还是 [0, len) 这个开区间. 如果是闭区间，则循环条件使用 while(left &lt;= right)；如果是开区间，则使用while(left &lt; right)。很好理解，考虑列表只有一个因素的情况，闭区间是[1,1]需要等于搜索。 思考返回的问题： 如果元素是不重复的，可以直接if(nums[mid] == target) return mid;判断返回。 如果元素是重复的，需要考虑返回第一个重复元素还是最后一个重复元素的问题。 返回第一个：if (nums[mid] == target) right = mid - 1; 锁定左侧边界，返回值为：return nums[left] == target ? left : -1; 返回最后一个：if (nums[mid] == target) left = mid + 1; 锁定右侧边界，返回值为：nums[right] == target ? right : -1;"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-12-23T01:50:39.000Z"}],["meta",{"property":"article:author","content":"Yujie Liu"}],["meta",{"property":"article:tag","content":"Algorithms"}],["meta",{"property":"article:tag","content":"Leetcode"}],["meta",{"property":"article:tag","content":"Binary Search"}],["meta",{"property":"article:modified_time","content":"2023-12-23T01:50:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Binary Search 二分搜索\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-23T01:50:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yujie Liu\\",\\"url\\":\\"https://blog.yujieliu.com/intro.html\\"}]}"]]},"headers":[],"git":{"createdTime":1703296239000,"updatedTime":1703296239000,"contributors":[{"name":"Yujie","email":"yujie.liu.public@gmail.com","commits":1}]},"readingTime":{"minutes":1.61,"words":482},"filePathRelative":"blogs/algorithm/binary-search.md","localizedDate":"December 23, 2023","excerpt":"<h1> Binary Search 二分搜索</h1>\\n<p>二分搜索的关键在于：</p>\\n<ol>\\n<li>搜索 <code>[0, len-1]</code> 这个闭区间，还是 <code>[0, len)</code> 这个开区间.</li>\\n<li>如果是闭区间，则循环条件使用 <code>while(left &lt;= right)</code>；如果是开区间，则使用<code>while(left &lt; right)</code>。很好理解，考虑列表只有一个因素的情况，闭区间是<code>[1,1]</code>需要等于搜索。</li>\\n<li>思考返回的问题：\\n<ul>\\n<li>如果元素是不重复的，可以直接<code>if(nums[mid] == target) return mid;</code>判断返回。</li>\\n<li>如果元素是重复的，需要考虑返回第一个重复元素还是最后一个重复元素的问题。\\n<ul>\\n<li>返回第一个：<code>if (nums[mid] == target) right = mid - 1;</code> 锁定左侧边界，返回值为：<code>return nums[left] == target ? left : -1;</code></li>\\n<li>返回最后一个：<code>if (nums[mid] == target) left = mid + 1;</code> 锁定右侧边界，返回值为：<code>nums[right] == target ? right : -1;</code></li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}`);export{e as data};
