const t=JSON.parse(`{"key":"v-1860c072","path":"/blogs/java/concurrency/producer-customer.html","title":"生产者消费者模型","lang":"en-US","frontmatter":{"description":"生产者消费者模型 单元素的生产者消费者模型 生产一个，消费一个，因此生产和消费需要交叉进行 以下使用Lock Condition的 await/signal 机制为例。 消费者线程 awaitThread 先通过 lock.lock() 方法获取锁，成功后发现还未生产，只能调用 condition.await 方法进入等待队列； 另一个生产者线程 signalThread 通过 lock.lock() 方法获取锁成功后进行生产，然后调用 condition.signal 或者 signalAll 方法，使得消费者线程 awaitThread 能够有机会移入到同步队列中； 当其他线程释放 lock 后使得线程 awaitThread 能够有机会获取 lock，从而使得线程 awaitThread 能够从 await 方法中退出并执行后续操作。如果 awaitThread 获取 lock 失败会直接进入到同步队列。","head":[["meta",{"property":"og:url","content":"https://blog.yujieliu.com/blogs/java/concurrency/producer-customer.html"}],["meta",{"property":"og:site_name","content":"Yujie's blog"}],["meta",{"property":"og:title","content":"生产者消费者模型"}],["meta",{"property":"og:description","content":"生产者消费者模型 单元素的生产者消费者模型 生产一个，消费一个，因此生产和消费需要交叉进行 以下使用Lock Condition的 await/signal 机制为例。 消费者线程 awaitThread 先通过 lock.lock() 方法获取锁，成功后发现还未生产，只能调用 condition.await 方法进入等待队列； 另一个生产者线程 signalThread 通过 lock.lock() 方法获取锁成功后进行生产，然后调用 condition.signal 或者 signalAll 方法，使得消费者线程 awaitThread 能够有机会移入到同步队列中； 当其他线程释放 lock 后使得线程 awaitThread 能够有机会获取 lock，从而使得线程 awaitThread 能够从 await 方法中退出并执行后续操作。如果 awaitThread 获取 lock 失败会直接进入到同步队列。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-03-15T17:45:22.000Z"}],["meta",{"property":"article:author","content":"Yujie Liu"}],["meta",{"property":"article:modified_time","content":"2024-03-15T17:45:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"生产者消费者模型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-15T17:45:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yujie Liu\\",\\"url\\":\\"https://blog.yujieliu.com/intro.html\\"}]}"]]},"headers":[{"level":2,"title":"单元素的生产者消费者模型","slug":"单元素的生产者消费者模型","link":"#单元素的生产者消费者模型","children":[]},{"level":2,"title":"多元素的生产者消费者模型（队列）","slug":"多元素的生产者消费者模型-队列","link":"#多元素的生产者消费者模型-队列","children":[]}],"git":{"createdTime":1710524722000,"updatedTime":1710524722000,"contributors":[{"name":"Jeff Liu","email":"47711081+LiuLiujie@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":1.14,"words":341},"filePathRelative":"blogs/java/concurrency/producer-customer.md","localizedDate":"March 15, 2024","excerpt":"<h1> 生产者消费者模型</h1>\\n<h2> 单元素的生产者消费者模型</h2>\\n<p><strong>生产一个，消费一个，因此生产和消费需要交叉进行</strong></p>\\n<img src=\\"https://pics.yujieliu.com/blog/2023/12/500069f45f64612c47e88d86d42b9f1d.png\\" alt=\\"img\\" style=\\"zoom:50%;\\">\\n<p>以下使用Lock Condition的 await/signal 机制为例。</p>\\n<ul>\\n<li>\\n<p>消费者线程 awaitThread 先通过 <code>lock.lock()</code> 方法获取锁，成功后发现还未生产，只能调用 condition.await 方法进入等待队列；</p>\\n</li>\\n<li>\\n<p>另一个生产者线程 signalThread 通过 <code>lock.lock()</code> 方法获取锁成功后进行生产，然后调用 condition.signal 或者 signalAll 方法，使得消费者线程 awaitThread 能够有机会移入到同步队列中；</p>\\n</li>\\n<li>\\n<p>当其他线程释放 lock 后使得线程 awaitThread 能够有机会获取 lock，从而使得线程 awaitThread 能够从 await 方法中退出并执行后续操作。如果 awaitThread 获取 lock 失败会直接进入到同步队列。</p>\\n</li>\\n</ul>","autoDesc":true}`);export{t as data};
