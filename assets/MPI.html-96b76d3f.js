const e=JSON.parse(`{"key":"v-56ad03be","path":"/blogs/hpc/MPI.html","title":"MPI Tutorial","lang":"en-US","frontmatter":{"description":"MPI Tutorial Refer and conclude from the MPI Tutorial MPI: Message Passing Interface 程序通过在进程间传递消息（消息可以理解成带有一些信息和数据的一个数据结构）来完成某些任务 E.g.: 主进程（manager process）可以通过对从进程（worker process）发送一个描述工作的消息来把这个工作分配给它。另一个例子就是一个并发的排序程序可以在当前进程中对当前进程可见的（我们称作本地的，locally）数据进行排序，然后把排好序的数据发送的邻居进程上面来进行合并的操作。","head":[["meta",{"property":"og:url","content":"https://blog.yujieliu.com/blogs/hpc/MPI.html"}],["meta",{"property":"og:site_name","content":"Yujie's blog"}],["meta",{"property":"og:title","content":"MPI Tutorial"}],["meta",{"property":"og:description","content":"MPI Tutorial Refer and conclude from the MPI Tutorial MPI: Message Passing Interface 程序通过在进程间传递消息（消息可以理解成带有一些信息和数据的一个数据结构）来完成某些任务 E.g.: 主进程（manager process）可以通过对从进程（worker process）发送一个描述工作的消息来把这个工作分配给它。另一个例子就是一个并发的排序程序可以在当前进程中对当前进程可见的（我们称作本地的，locally）数据进行排序，然后把排好序的数据发送的邻居进程上面来进行合并的操作。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-11-25T09:26:15.000Z"}],["meta",{"property":"article:author","content":"Yujie Liu"}],["meta",{"property":"article:modified_time","content":"2023-11-25T09:26:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MPI Tutorial\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-11-25T09:26:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yujie Liu\\",\\"url\\":\\"https://blog.yujieliu.com/intro.html\\"}]}"]]},"headers":[{"level":2,"title":"MPI Helloworld","slug":"mpi-helloworld","link":"#mpi-helloworld","children":[]},{"level":2,"title":"MPI Send an Receive","slug":"mpi-send-an-receive","link":"#mpi-send-an-receive","children":[{"level":3,"title":"Data Type","slug":"data-type","link":"#data-type","children":[]},{"level":3,"title":"Send / Receive Program","slug":"send-receive-program","link":"#send-receive-program","children":[]},{"level":3,"title":"Ping-Pong Program","slug":"ping-pong-program","link":"#ping-pong-program","children":[]},{"level":3,"title":"Ring program","slug":"ring-program","link":"#ring-program","children":[]}]},{"level":2,"title":"Dynamic Receiving with MPI Probe (and MPI Status)","slug":"dynamic-receiving-with-mpi-probe-and-mpi-status","link":"#dynamic-receiving-with-mpi-probe-and-mpi-status","children":[{"level":3,"title":"MPI_Status Struct","slug":"mpi-status-struct","link":"#mpi-status-struct","children":[]},{"level":3,"title":"Use MPI_Probe to query the size of incoming data","slug":"use-mpi-probe-to-query-the-size-of-incoming-data","link":"#use-mpi-probe-to-query-the-size-of-incoming-data","children":[]}]},{"level":2,"title":"Point-to-Point Communication Application - Random Walk","slug":"point-to-point-communication-application-random-walk","link":"#point-to-point-communication-application-random-walk","children":[{"level":3,"title":"随机游走问题的并行化","slug":"随机游走问题的并行化","link":"#随机游走问题的并行化","children":[]},{"level":3,"title":"使用 MPI_Send 和 MPI_Recv 组织代码","slug":"使用-mpi-send-和-mpi-recv-组织代码","link":"#使用-mpi-send-和-mpi-recv-组织代码","children":[]},{"level":3,"title":"死锁及预防","slug":"死锁及预防","link":"#死锁及预防","children":[]},{"level":3,"title":"Determining completion of all walkers","slug":"determining-completion-of-all-walkers","link":"#determining-completion-of-all-walkers","children":[]}]}],"git":{"createdTime":1700904375000,"updatedTime":1700904375000,"contributors":[{"name":"Yujie","email":"yujie.liu.public@gmail.com","commits":1}]},"readingTime":{"minutes":18.56,"words":5569},"filePathRelative":"blogs/hpc/MPI.md","localizedDate":"November 25, 2023","excerpt":"<h1> MPI Tutorial</h1>\\n<p>Refer and conclude from the <a href=\\"https://mpitutorial.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">MPI Tutorial</a></p>\\n<p>MPI: Message Passing Interface</p>\\n<ul>\\n<li>程序通过在进程间传递消息（消息可以理解成带有一些信息和数据的一个数据结构）来完成某些任务</li>\\n<li>E.g.: 主进程（manager process）可以通过对从进程（worker process）发送一个描述工作的消息来把这个工作分配给它。另一个例子就是一个并发的排序程序可以在当前进程中对当前进程可见的（我们称作本地的，locally）数据进行排序，然后把排好序的数据发送的邻居进程上面来进行合并的操作。</li>\\n</ul>","autoDesc":true}`);export{e as data};
