const e=JSON.parse(`{"key":"v-44d4f1f0","path":"/projects/stryker-cloud-agent/redis-mq.html","title":"Use Redis As MQ 使用Redis做消息队列","lang":"en-US","frontmatter":{"description":"Use Redis As MQ 使用Redis做消息队列 Redis Stream 做消息队列详解 项目中使用 Redis Stream 作为消息队列。建立了三个消费者组，分别是mutants, results 和 logs runner会将运行结果发回到orchestrator后存入各自的的消息队列中，而前端用户则会从消费者组中消费对某个项目的全部的结果。","head":[["meta",{"property":"og:url","content":"https://blog.yujieliu.com/projects/stryker-cloud-agent/redis-mq.html"}],["meta",{"property":"og:site_name","content":"Yujie's blog"}],["meta",{"property":"og:title","content":"Use Redis As MQ 使用Redis做消息队列"}],["meta",{"property":"og:description","content":"Use Redis As MQ 使用Redis做消息队列 Redis Stream 做消息队列详解 项目中使用 Redis Stream 作为消息队列。建立了三个消费者组，分别是mutants, results 和 logs runner会将运行结果发回到orchestrator后存入各自的的消息队列中，而前端用户则会从消费者组中消费对某个项目的全部的结果。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-11-29T21:15:41.000Z"}],["meta",{"property":"article:author","content":"Yujie Liu"}],["meta",{"property":"article:modified_time","content":"2023-11-29T21:15:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Use Redis As MQ 使用Redis做消息队列\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-11-29T21:15:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yujie Liu\\",\\"url\\":\\"https://blog.yujieliu.com/intro.html\\"}]}"]]},"headers":[],"git":{"createdTime":1701287649000,"updatedTime":1701292541000,"contributors":[{"name":"Yujie","email":"yujie.liu.public@gmail.com","commits":2}]},"readingTime":{"minutes":0.34,"words":102},"filePathRelative":"projects/stryker-cloud-agent/redis-mq.md","localizedDate":"November 29, 2023","excerpt":"<h1> Use Redis As MQ 使用Redis做消息队列</h1>\\n<p><a href=\\"/blogs/devops/redis/stream-message-queue.html\\" target=\\"blank\\">Redis Stream 做消息队列详解</a></p>\\n<p>项目中使用 Redis Stream 作为消息队列。建立了三个消费者组，分别是<code>mutants</code>, <code>results</code> 和 <code>logs</code></p>\\n<p>runner会将运行结果发回到orchestrator后存入各自的的消息队列中，而前端用户则会从消费者组中消费对某个项目的全部的结果。</p>","autoDesc":true}`);export{e as data};
