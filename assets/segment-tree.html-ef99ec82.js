const e=JSON.parse(`{"key":"v-69b5972c","path":"/blogs/algorithm/segment-tree.html","title":"Segment Tree 线段树","lang":"en-US","frontmatter":{"category":"Computer Science","tag":["Algorithms","Leetcode"],"description":"Segment Tree 线段树 线段树解决的是「区间和」的问题，且该「区间」会被修改 一个区间的例子是对于 nums = [1, 2, 3, 4, 5] 多次求某些区间的和，是不是首先想到了利用「前缀和」。 但是如果 nums 会被修改呢？比如： 把第 i 个元素修改成 x 把第 i 个元素增加 x 把区间 [i, j] 内的元素都增加 x 此时，如果我们再使用「前缀和」，就没那么高效了。因为每一次更新，前缀和数组必须也随之更新，时间复杂度为 O(n)。","head":[["meta",{"property":"og:url","content":"https://blog.yujieliu.com/blogs/algorithm/segment-tree.html"}],["meta",{"property":"og:site_name","content":"Yujie's blog"}],["meta",{"property":"og:title","content":"Segment Tree 线段树"}],["meta",{"property":"og:description","content":"Segment Tree 线段树 线段树解决的是「区间和」的问题，且该「区间」会被修改 一个区间的例子是对于 nums = [1, 2, 3, 4, 5] 多次求某些区间的和，是不是首先想到了利用「前缀和」。 但是如果 nums 会被修改呢？比如： 把第 i 个元素修改成 x 把第 i 个元素增加 x 把区间 [i, j] 内的元素都增加 x 此时，如果我们再使用「前缀和」，就没那么高效了。因为每一次更新，前缀和数组必须也随之更新，时间复杂度为 O(n)。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-03-15T17:45:22.000Z"}],["meta",{"property":"article:author","content":"Yujie Liu"}],["meta",{"property":"article:tag","content":"Algorithms"}],["meta",{"property":"article:tag","content":"Leetcode"}],["meta",{"property":"article:modified_time","content":"2024-03-15T17:45:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Segment Tree 线段树\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-15T17:45:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yujie Liu\\",\\"url\\":\\"https://blog.yujieliu.com/intro.html\\"}]}"]]},"headers":[{"level":2,"title":"线段树","slug":"线段树","link":"#线段树","children":[]}],"git":{"createdTime":1710524722000,"updatedTime":1710524722000,"contributors":[{"name":"Jeff Liu","email":"47711081+LiuLiujie@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":0.71,"words":213},"filePathRelative":"blogs/algorithm/segment-tree.md","localizedDate":"March 15, 2024","excerpt":"<h1> Segment Tree 线段树</h1>\\n<p><strong>线段树解决的是「区间和」的问题，且该「区间」会被修改</strong></p>\\n<p>一个区间的例子是对于 <code>nums = [1, 2, 3, 4, 5]</code> 多次求某些区间的和，是不是首先想到了利用「前缀和」。</p>\\n<p>但是如果 nums 会被修改呢？比如：</p>\\n<ul>\\n<li>把第 i 个元素修改成 x</li>\\n<li>把第 i 个元素增加 x</li>\\n<li>把区间 [i, j] 内的元素都增加 x</li>\\n</ul>\\n<p>此时，如果我们再使用「前缀和」，就没那么高效了。因为每一次更新，前缀和数组必须也随之更新，时间复杂度为 O(n)。</p>","autoDesc":true}`);export{e as data};
